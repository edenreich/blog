name: Build API and deploy to stage

on:
  push:
    branches:
      - develop
    paths:
      - ".github/workflows/api.yml"
      - "src/backend/api/**"
      - "ops/docker/backend/api/**"
      - "ops/kubernetes/backend/api/**"

env:
  DOCKER_BUILDKIT: 1
  DOCKER_REPO: edenr/blog-api
  DOCKER_IMAGE: blog-api
  STAGE_SERVERS: k8s-master k8s-node1 k8s-node2 k8s-node3 k8s-node4 k8s-node5 k8s-node6
  DEPLOYMENT_NAME: api
  DEPLOYMENT_VERSION: $(echo ${{ github.sha }} | cut -c1-8)

jobs:
  build:
    runs-on: self-hosted
    steps:
      - uses: actions/checkout@master
      - name: Docker build container image
        run: |
          docker build \
            --target production \
            --cache-from ${{ env.DOCKER_REPO }}:latest \
            -t ${{ env.DOCKER_REPO }}:latest \
            -f ops/docker/backend/api/Dockerfile .
      - name: Docker build test container image
        run: |
          docker build \
            --target test \
            --cache-from ${{ env.DOCKER_REPO }}-test:latest \
            -t ${{ env.DOCKER_REPO }}-test:latest \
            -f ops/docker/backend/api/Dockerfile .
      - name: Docker Tag Images
        run: |
          docker tag ${{ env.DOCKER_REPO }}:latest ${{ env.DOCKER_REPO }}:${{ env.DEPLOYMENT_VERSION }}
          docker tag ${{ env.DOCKER_REPO }}-test:latest ${{ env.DOCKER_REPO }}-test:${{ env.DEPLOYMENT_VERSION }}
  push:
    runs-on: self-hosted
    needs: build
    steps:
      - name: Docker Login
        run: docker login -u ${{ secrets.DOCKER_USERNAME }} -p '${{ secrets.DOCKER_PASSWORD }}'
      - name: Docker Push
        run: |
          docker push ${{ env.DOCKER_REPO }}:${{ env.DEPLOYMENT_VERSION }}
          docker push ${{ env.DOCKER_REPO }}-test:${{ env.DEPLOYMENT_VERSION }}
          docker push ${{ env.DOCKER_REPO }}:latest
          docker push ${{ env.DOCKER_REPO }}-test:latest
  analyse:
    runs-on: self-hosted
    needs: push
    steps:
      - name: Run static analysis
        run: |
          cat ops/kubernetes/backend/api/jobs/analyse.yaml | sed -e "s/{{VERSION}}/${{ env.DEPLOYMENT_VERSION }}/g" -e "s/{{REPOSITORY}}/${{ env.DOCKER_IMAGE }}-test/g" | kubectl apply -f -
  test:
    runs-on: self-hosted
    needs: analyse
    steps:
      - name: Run database migrations
        run: |
          cat ops/kubernetes/backend/api/jobs/migrations.yaml | sed -e "s/{{VERSION}}/${{ env.DEPLOYMENT_VERSION }}/g" -e "s/{{REPOSITORY}}/${{ env.DOCKER_IMAGE }}-test/g" | kubectl apply -f -
      - name: Load fixture database seeds
        run: |
          cat ops/kubernetes/backend/api/jobs/seed.yaml | sed -e "s/{{VERSION}}/${{ env.DEPLOYMENT_VERSION }}/g" -e "s/{{REPOSITORY}}/${{ env.DOCKER_IMAGE }}-test/g" | kubectl apply -f -
      - name: Run integration tests
        run: |
          cat ops/kubernetes/backend/api/jobs/run_tests.yaml | sed -e "s/{{VERSION}}/${{ env.DEPLOYMENT_VERSION }}/g" -e "s/{{REPOSITORY}}/${{ env.DOCKER_IMAGE }}-test/g" | kubectl apply -f -
  migrations:
    runs-on: self-hosted
    needs: push
    steps:
      - name: Run database migrations
        run: |
          cat ops/kubernetes/backend/api/jobs/migrations.yaml | sed -e "s/{{VERSION}}/${{ env.DEPLOYMENT_VERSION }}/g" -e "s/{{REPOSITORY}}/${{ env.DOCKER_IMAGE }}/g" | kubectl apply -f -
  deploy:
    runs-on: self-hosted
    needs: migrations
    steps:
      - uses: actions/checkout@master
      - name: Kubernetes - switch to stage context
        run: kubectl config use-context stage
      - name: Kubernetes - create a new deployment
        run: cat ops/kubernetes/backend/api/deployment.yaml | sed -e "s/{{VERSION}}/${{ env.DEPLOYMENT_VERSION }}/g" -e "s/{{REPOSITORY}}/${{ env.DOCKER_IMAGE }}/g" | kubectl apply -f -
      - name: Kubernetes - wait for new deployment to be successfully rolled out
        run: |
          max_count=180
          count=0
          while [ true ]; do
            if [[ $count -gt $max_count ]]; then
              echo "===> Waited for too long for a successful rolled out green version, but something went wrong. Aborting..."
              exit 1
            fi
            if [[ $(kubectl rollout status deploy/${{ env.DEPLOYMENT_NAME }}-${{ env.DEPLOYMENT_VERSION }} | grep 'successfully rolled out') ]]; then
              break
            fi
            count=$((count+1))
            echo "===> New deployment ${{ env.DEPLOYMENT_NAME }}-${{ env.DEPLOYMENT_VERSION }} is being rollout out..."
            sleep 1
          done
      - name: Kubernetes - apply horizontal pods autoscaling to new deployment
        run: cat ops/kubernetes/backend/api/hpa.yaml | sed "s/{{VERSION}}/${{ env.DEPLOYMENT_VERSION }}/g" | kubectl apply -f -
      - name: Kubernetes - switch LB to green deployment
        run: cat ops/kubernetes/backend/api/service.yaml | sed "s/{{VERSION}}/${{ env.DEPLOYMENT_VERSION }}/g" | kubectl apply -f -
  cleanup:
    runs-on: self-hosted
    needs: deploy
    steps:
      - name: Remove all related images from github-runner except latest
        run: docker rmi -f $(docker images | grep ${{ env.DOCKER_REPO }} | grep -v latest | awk '{image = sprintf("%s:%s", $1,$2)} END {print image}' | xargs) || true
      - name: Remove Dangling Docker Images
        run: docker system prune -f
      - name: Keep 5 container images
        run: for server in $(echo ${{ env.STAGE_SERVERS }} | xargs); do ssh $server ./scripts/cleanup.sh; done
      - name: Keep 2 deployments available for rollback
        run: kubectl delete deployments $(kubectl get deployments | grep ${{ env.DEPLOYMENT_NAME }} | awk '{ print $1 }' | sort -rn | tail -n+3) || true
